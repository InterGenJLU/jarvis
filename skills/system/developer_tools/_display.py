"""
Developer Tools — Visual Display Module

Routes output to terminal (gnome-terminal) or VS Code based on content type.
"""

import os
import subprocess
import tempfile
import time
from typing import Optional

from core.logger import get_logger

# Content types that should open in VS Code (long/structured)
VSCODE_CONTENT_TYPES = {
    'git_diff', 'codebase_search', 'file_contents', 'log_output',
}

# Content types that should open in terminal (short/ephemeral)
TERMINAL_CONTENT_TYPES = {
    'process_list', 'service_status', 'network_info', 'git_status',
    'git_branch', 'disk_usage', 'package_list', 'health_check',
}

# Line threshold — above this, use VS Code regardless
VSCODE_LINE_THRESHOLD = 50


class DisplayRouter:
    """Routes command output to appropriate visual display."""

    def __init__(self, config):
        self.config = config
        self.logger = get_logger('DisplayRouter', config)
        self._temp_dir = '/tmp'

    def show(self, output: str, content_type: str = 'unknown',
             title: str = 'JARVIS Output', force_backend: Optional[str] = None) -> bool:
        """
        Display output visually.

        Args:
            output: The raw command output to display
            content_type: Type hint for backend selection (e.g. 'git_diff', 'process_list')
            title: Window title or filename hint
            force_backend: 'terminal' or 'vscode' to override auto-detection

        Returns:
            True if display was opened successfully
        """
        if not output or not output.strip():
            self.logger.warning("Empty output, nothing to display")
            return False

        backend = force_backend or self._select_backend(output, content_type)

        if backend == 'vscode':
            return self._open_in_vscode(output, title)
        else:
            return self._open_in_terminal(output, title)

    def _select_backend(self, output: str, content_type: str) -> str:
        """Select display backend based on content type and output size."""
        # Explicit content type mapping
        if content_type in VSCODE_CONTENT_TYPES:
            return 'vscode'
        if content_type in TERMINAL_CONTENT_TYPES:
            # But if output is very long, upgrade to VS Code
            line_count = output.count('\n') + 1
            if line_count > VSCODE_LINE_THRESHOLD:
                return 'vscode'
            return 'terminal'

        # Unknown type — decide by length
        line_count = output.count('\n') + 1
        if line_count > VSCODE_LINE_THRESHOLD:
            return 'vscode'
        return 'terminal'

    def _open_in_vscode(self, output: str, title: str) -> bool:
        """Write output to temp file and open in VS Code."""
        try:
            # Create descriptive filename
            safe_title = title.lower().replace(' ', '_').replace('/', '_')[:40]
            timestamp = time.strftime('%H%M%S')
            filename = f"jarvis_{safe_title}_{timestamp}.txt"
            filepath = os.path.join(self._temp_dir, filename)

            with open(filepath, 'w') as f:
                f.write(f"# {title}\n")
                f.write(f"# Generated by JARVIS at {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                f.write(output)

            env = os.environ.copy()
            env['DISPLAY'] = ':0'

            subprocess.Popen(
                ['code', filepath],
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )

            self.logger.info(f"Opened output in VS Code: {filepath}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to open in VS Code: {e}")
            return False

    def _open_in_terminal(self, output: str, title: str) -> bool:
        """Open output in a gnome-terminal window with less."""
        try:
            # Write to temp file for less to read
            safe_title = title.lower().replace(' ', '_').replace('/', '_')[:40]
            timestamp = time.strftime('%H%M%S')
            filename = f"jarvis_{safe_title}_{timestamp}.txt"
            filepath = os.path.join(self._temp_dir, filename)

            with open(filepath, 'w') as f:
                f.write(output)

            env = os.environ.copy()
            env['DISPLAY'] = ':0'

            subprocess.Popen(
                [
                    'gnome-terminal', '--title', title,
                    '--', 'bash', '-c', f'less -R "{filepath}"; rm -f "{filepath}"'
                ],
                env=env,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )

            self.logger.info(f"Opened output in terminal: {filepath}")
            return True

        except Exception as e:
            self.logger.error(f"Failed to open terminal: {e}")
            return False

    @staticmethod
    def detect_show_me(text: str) -> Optional[str]:
        """
        Check if user utterance is a 'show me' request.
        Returns the forced backend if specified, or 'auto' if show-me detected, None otherwise.
        """
        lower = text.lower().strip()

        # Check for backend override
        if 'in terminal' in lower or 'in the terminal' in lower:
            return 'terminal'
        if 'in code' in lower or 'in vs code' in lower or 'in vscode' in lower:
            return 'vscode'

        # Check for show-me trigger phrases
        show_prefixes = ['show me', 'let me see', 'display', 'pull up', 'open up']
        for prefix in show_prefixes:
            if lower.startswith(prefix):
                return 'auto'

        return None
